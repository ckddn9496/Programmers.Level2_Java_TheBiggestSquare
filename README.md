# Programmers.Level2_Java_TheBiggestSquare

## 프로그래머스 > 연습문제 > 가장 큰 정사각형 찾기

### 1. 문제설명

문제: https://programmers.co.kr/learn/courses/30/lessons/12905

input으로 1과 0으로 채워진 표 int[][] board가 들어온다. 표 한칸은 1\*1의 정사각형으로 이루어져 있으며 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return하는 문제이다.

### 2. 풀이

board의 양변의 길이 중 더 짧은 변의 길이부터 시작해서 비트연산자 **AND** 를 이용하여 모든 경우를 탐색하는 Brute Force방법도 있지만 이 문제에는 효율성 점수가 별도로 있어 DP를 이용하였다.

풀이 설명이 어렵고 문제를 푸는과정에서 펜을 꺼내지 않으면 안됬었다. 표의 1,1부터 row,col까지 연속하여 0이 아닌 숫자가 존재하여야만 큰 사각형을 만들 수 있으며, 정사각형이기 때문에 행과 열에서 동시에 0이 아닌값이 나와야만 함을 알 수 있었다. 1,1부터 시작하여 오른쪽 아래로 인덱스를 순차적으로 검사해가며 해당 셀 값이 0이 아니라면 누적된 정사각형의 길이를 구하기 위해 이전 행, 열, 왼쪽위 대각선값중 가장 최소값 + 1의 값을 넣어주었다. 값이 0이라면 그곳에서 정사각형의 변이 끊기기 때문에 그 값은 0으로 두었다. 각 셀의 값은 만들수 있는 정사각형의 한변의 길이를 의미하므로 매 검사마다 max값과 셀값을 비교하여 max보다 큰 정사각형을 만들 수 있다면 그떄마다 max값을 갱신해주어 다시 모든 표를 탐색하지 않아도 되도록 하였다. 마지막은 넓이를 return해야 하므로 max\*max를 return해주어 해결하였다.

```java
for (int i = 1; i < row; i++) {
  for (int j = 1; j < col; j++) {
    if (board[i][j] == 1) {
      board[i][j] = Math.min(Math.min(board[i-1][j], board[i-1][j-1]), board[i][j-1]) + 1;
      if (max < board[i][j])
        max = board[i][j];
    }
  }
}
return max*max;
```

### 3. 빼먹었던 점

이전값을 참조하여 생성할수 있는 정사각형의 길이를 저장하므로 탐색을 시작하는 인덱스가 1,1부터이다. 제출하고 1번에서 틀려서 뭔가했는데 양변중 한변의 길이가 1이면 ArrayIndexOurOfBound에러가 나온다. 이를 위해 시작시 row나 col값중 2보다 작은 값이 존재한다면 최대 만들어질 수 있는 정사각형의 한변의 길이가 1, 최소가 0이다. 한번이라도 1의 값을 갖는 셀이 존재한다면 곧바로 1을 return, 그렇지 않다면 0을 return하게하여 해결하였다.

```java
if (row < 2 || col < 2) {
  for (int i = 0; i < row; i++) {
    for (int j = 0; j < col; j++) {
      if (board[i][j] == 1)
        return 1;
    }
  }
  return 0;
}
```
